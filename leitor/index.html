<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Leitor de Gabaritos (Foto para CSV)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f9;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .container {
            background-color: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: 100%;
            text-align: center;
            margin-bottom: 20px;
        }
        h1 { color: #333; }
        input[type="file"], input[type="text"], input[type="number"] {
            margin: 10px 0;
            padding: 12px;
            border: 1px solid #ccc;
            border-radius: 5px;
            width: 100%;
            box-sizing: border-box;
        }
        input[type="text"]:disabled { background-color: #e9ecef; color: #6c757d; }
        #gabarito-preview {
            max-width: 100%;
            max-height: 500px; /* Aumentado para melhor visualiza√ß√£o */
            margin-top: 15px;
            border: 1px solid #ddd;
            display: none;
        }
        #resultado {
            margin-top: 20px;
            padding: 15px;
            border: 1px solid #007bff;
            background-color: #e9f5ff;
            color: #007bff;
            border-radius: 5px;
            display: none;
            text-align: left;
        }
        .button-group { margin-top: 20px; display: flex; gap: 10px; justify-content: center; }
        button {
            padding: 12px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s;
        }
        #btn-definir-estrutura { background-color: #007bff; color: white; }
        #btn-definir-estrutura:hover { background-color: #0056b3; }
        #processar-gabarito { background-color: #28a745; color: white; }
        #processar-gabarito:hover { background-color: #1e7e34; }
        #encerrar-gabaritos { background-color: #dc3545; color: white; width: 100%; margin-top: 30px; }
        #encerrar-gabaritos:hover { background-color: #c82333; }
        #encerrar-gabaritos:disabled, button:disabled { background-color: #f4f4f9; color: #6c757d; cursor: not-allowed; }

        /* Estilos para as Se√ß√µes */
        #config-section, #gabarito-oficial-section, #input-section {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            text-align: left;
        }
        #input-section { display: none; }
        #gabarito-respostas-area {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        /* Canvas oculto para manipula√ß√£o de imagem pelo OpenCV */
        #process-canvas { display: none; } 
    </style>
</head>
<body>
    <div class="container">
        <h1>üì∏ Leitor de Gabaritos</h1>

        <div id="config-section">
            <h3>1. Configura√ß√£o da Prova</h3>
            <p>Informe a estrutura da prova. Use o modelo de gabarito com 4 marcas de refer√™ncia (Quadrados Pretos).</p>
            <input type="number" id="num-questoes" placeholder="N√∫mero de Quest√µes (Ex: 50)" min="1" required>
            <input type="number" id="num-alternativas" placeholder="N√∫mero de Alternativas (Ex: 5)" min="2" max="5" required>
            <input type="number" id="num-pontos-referencia" value="4" disabled style="background-color: #f0f0f0;" title="O modelo de gabarito usa 4 pontos de refer√™ncia fixos." required>
            
            <input type="text" id="turma-input" placeholder="Turma (Ex: 8A, 3¬∫ Ano B)" required>

            <button id="btn-definir-estrutura" disabled style="width: 100%; margin-top: 15px;">Definir Estrutura</button>
        </div>

        <div id="gabarito-oficial-section" style="display: none; margin-bottom: 20px;">
             <h3>2. Gabarito Oficial</h3>
             <p>Preencha as respostas corretas. Use A, B, C, D, E, etc.</p>
             <div id="gabarito-respostas-area">
                </div>
             <button id="btn-iniciar-leitura" disabled style="width: 100%; margin-top: 15px; background-color: #28a745;">Iniciar Leitura dos Alunos</button>
        </div>

        <div id="input-section">
            <h3>3. Leitura dos Gabaritos</h3>
            
            <input type="text" id="aluno-input" placeholder="Nome Completo do Aluno" required>

            <input type="file" id="gabarito-input" accept="image/*">
            <img id="gabarito-preview" alt="Pr√©-visualiza√ß√£o do Gabarito" style="border: 2px solid #dc3545;">

            <div class="button-group">
                <button id="processar-gabarito" disabled>Processar Gabarito</button>
            </div>
            
            <div id="resultado">Aguardando OpenCV.js...</div>
            
            <p style="margin-top: 15px; text-align: center; color: #6c757d;">Alunos processados: <span id="alunos-count">0</span></p>

            <button id="encerrar-gabaritos" disabled>Encerrar Gabaritos da Turma (Gerar CSV)</button>
        </div>

        <canvas id="process-canvas"></canvas>
    </div>

    <a href="https://relatoriotri.vercel.app/" style="margin-top: 20px; display: inline-block;">‚Ü©Ô∏è Voltar para a P√°gina de An√°lise de Resultados</a>

    <script async src="https://docs.opencv.org/4.x/opencv.js" onload="onOpenCvReady()"></script>
    
    <script>
        // Vari√°vel global que ser√° preenchida quando o OpenCV estiver pronto
        let cv = null; 
        
        // Elementos de UI
        const turmaInput = document.getElementById('turma-input');
        const alunoInput = document.getElementById('aluno-input');
        const gabaritoInput = document.getElementById('gabarito-input');
        const gabaritoPreview = document.getElementById('gabarito-preview');
        const resultadoDiv = document.getElementById('resultado');
        const processarBtn = document.getElementById('processar-gabarito');
        const encerrarBtn = document.getElementById('encerrar-gabaritos');
        const alunosCountSpan = document.getElementById('alunos-count');
        const numQuestoesInput = document.getElementById('num-questoes');
        const numAlternativasInput = document.getElementById('num-alternativas');
        const definirEstruturaBtn = document.getElementById('btn-definir-estrutura');
        const configSection = document.getElementById('config-section');
        const gabaritoOficialSection = document.getElementById('gabarito-oficial-section');
        const gabaritoRespostasArea = document.getElementById('gabarito-respostas-area');
        const iniciarLeituraBtn = document.getElementById('btn-iniciar-leitura');
        const inputSection = document.getElementById('input-section');
        const processCanvas = document.getElementById('process-canvas');


        // Vari√°veis de Estado
        let dadosGabaritos = [];
        let gabaritoParaProcessar = null;
        let gabaritoOficialRespostas = [];
        let NUM_QUESTOES = 0;
        let NUM_ALTERNATIVAS = 0;

        // --------------------------------------------------------
        // A. CONTROLE DE CARREGAMENTO (OPENCV)
        // --------------------------------------------------------
        function onOpenCvReady() {
            cv = window.cv;
            if (cv && cv.Mat) {
                resultadoDiv.textContent = "OpenCV.js carregado com sucesso. Defina a estrutura da prova.";
            } else {
                resultadoDiv.textContent = "Erro ao carregar OpenCV.js. Verifique sua conex√£o.";
            }
        }
        
        // B. CONFIGURA√á√ÉO E DEFINI√á√ÉO DO GABARITO OFICIAL
        numQuestoesInput.addEventListener('input', validarConfig);
        numAlternativasInput.addEventListener('input', validarConfig);
        turmaInput.addEventListener('input', validarConfig);
        
        function validarConfig() {
            const numQ = parseInt(numQuestoesInput.value);
            const numA = parseInt(numAlternativasInput.value);
            const turmaValida = turmaInput.value.trim() !== '';
            
            if (numQ >= 1 && numA >= 2 && numA <= 5 && turmaValida) {
                definirEstruturaBtn.disabled = false;
            } else {
                definirEstruturaBtn.disabled = true;
            }
        }

        definirEstruturaBtn.addEventListener('click', function() {
            NUM_QUESTOES = parseInt(numQuestoesInput.value);
            NUM_ALTERNATIVAS = parseInt(numAlternativasInput.value);
            
            renderizarInputsGabaritoOficial();
            
            configSection.style.display = 'none';
            gabaritoOficialSection.style.display = 'block';
        });

        function renderizarInputsGabaritoOficial() {
            gabaritoRespostasArea.innerHTML = '';
            
            const alternativas = ['A', 'B', 'C', 'D', 'E'].slice(0, NUM_ALTERNATIVAS);

            for (let i = 1; i <= NUM_QUESTOES; i++) {
                const div = document.createElement('div');
                div.innerHTML = `
                    <label for="q${i}" style="font-weight: bold;">Q${i}:</label>
                    <select id="q${i}" required style="width: 100%; padding: 8px;">
                        <option value="">--</option>
                        ${alternativas.map(alt => `<option value="${alt}">${alt}</option>`).join('')}
                    </select>
                `;
                gabaritoRespostasArea.appendChild(div);
            }
            
            gabaritoRespostasArea.addEventListener('change', validarGabaritoOficial);
            validarGabaritoOficial();
        }
        
        function validarGabaritoOficial() {
            const selects = gabaritoRespostasArea.querySelectorAll('select');
            let preenchido = true;
            selects.forEach(select => {
                if (select.value === "") {
                    preenchido = false;
                }
            });
            iniciarLeituraBtn.disabled = !preenchido;
            resultadoDiv.textContent = "Preencha todas as respostas corretas para iniciar a leitura dos alunos.";
        }

        iniciarLeituraBtn.addEventListener('click', function() {
            gabaritoOficialRespostas = [];
            const selects = gabaritoRespostasArea.querySelectorAll('select');
            selects.forEach(select => {
                gabaritoOficialRespostas.push(select.value);
            });
            
            turmaInput.disabled = true;
            gabaritoOficialSection.style.display = 'none';
            inputSection.style.display = 'block';
            resultadoDiv.textContent = `Gabarito Oficial (Q1-Q${NUM_QUESTOES}) definido. Turma ${turmaInput.value} travada. Pronto para a leitura do primeiro aluno.`;
            resultadoDiv.style.display = 'block';
        });

        // C. L√ìGICA DE LEITURA DE ARQUIVO
        gabaritoInput.addEventListener('change', function() {
            const file = this.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    gabaritoPreview.src = e.target.result;
                    gabaritoPreview.style.display = 'block';
                    gabaritoParaProcessar = e.target.result; 
                    validarFormularioAluno();
                }
                reader.readAsDataURL(file);
            } else {
                gabaritoPreview.style.display = 'none';
                gabaritoParaProcessar = null;
                validarFormularioAluno();
            }
        });
        
        alunoInput.addEventListener('input', validarFormularioAluno);

        function validarFormularioAluno() {
            const alunoValido = alunoInput.value.trim() !== '';
            if (alunoValido && gabaritoParaProcessar && cv) { 
                processarBtn.disabled = false;
            } else {
                processarBtn.disabled = true;
            }
        }

        processarBtn.addEventListener('click', async function() {
            processarBtn.disabled = true;
            encerrarBtn.disabled = true; 
            
            const turma = turmaInput.value.trim();
            const aluno = alunoInput.value.trim();

            if (!aluno || !gabaritoParaProcessar) {
                 resultadoDiv.textContent = "Erro: Por favor, preencha o nome do aluno e envie a imagem.";
                 processarBtn.disabled = false;
                 return;
            }
            
            resultadoDiv.textContent = `Processando gabarito de ${aluno} (${turma}) com Vis√£o Computacional...`;
            
            try {
                // >> CHAMA A FUN√á√ÉO REAL DE PROCESSAMENTO DA IMAGEM <<
                const respostasAluno = await processarImagemOpenCV(gabaritoParaProcessar); 
                
                const dadosDoAluno = {
                    "Aluno": aluno,
                    ...respostasAluno 
                };
                
                dadosGabaritos.push(dadosDoAluno);

                // Reseta e Atualiza a Interface
                alunoInput.value = '';
                gabaritoInput.value = '';
                gabaritoParaProcessar = null;

                processarBtn.disabled = true;
                encerrarBtn.disabled = false;
                alunosCountSpan.textContent = dadosGabaritos.length;
                
                // Exibe as respostas lidas para depura√ß√£o
                const respostasLidas = Object.entries(respostasAluno).map(([q, r]) => `${q}: ${r}`).join(', ');
                resultadoDiv.innerHTML = `‚úÖ Gabarito de <strong>${aluno}</strong> processado! Total: ${dadosGabaritos.length}. <br> Respostas lidas (Q1-Q${NUM_QUESTOES}): ${respostasLidas}. Envie o pr√≥ximo ou Encerrar.`;
                resultadoDiv.style.backgroundColor = '#d4edda';
                resultadoDiv.style.borderColor = '#c3e6cb';
                resultadoDiv.style.color = '#155724';
            } catch (error) {
                console.error("Erro no processamento OpenCV:", error);
                resultadoDiv.textContent = `‚ùå Erro ao processar gabarito: ${error.message || 'Erro desconhecido'}. Tente outra foto.`;
                resultadoDiv.style.backgroundColor = '#f8d7da';
                resultadoDiv.style.borderColor = '#f5c6cb';
                resultadoDiv.style.color = '#721c24';
                processarBtn.disabled = false;
                encerrarBtn.disabled = dadosGabaritos.length === 0;
            }
        });
        
        
        // --------------------------------------------------------
        // D. FUN√á√ÉO DE VIS√ÉO COMPUTACIONAL (L√ìGICA AJUSTADA PARA CALIBRA√á√ÉO)
        // --------------------------------------------------------
        
        // DIMENS√ïES FIXAS DA IMAGEM AP√ìS A CORRE√á√ÉO DE PERSPECTIVA
        const OUTPUT_WIDTH = 600; 
        const OUTPUT_HEIGHT = 850; 

        async function processarImagemOpenCV(imageDataURL) {
            
            const img = new Image();
            img.src = imageDataURL;
            await new Promise(resolve => img.onload = resolve);

            // 1. Carregar a Imagem no Canvas
            processCanvas.width = img.width;
            processCanvas.height = img.height;
            const ctx = processCanvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            // 2. Converter para Matriz (cv.Mat) e Escala de Cinza
            let src = cv.imread(processCanvas);
            let gray = new cv.Mat();
            cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
            
            // Vari√°veis tempor√°rias para limpeza de mem√≥ria
            let blurred = new cv.Mat();
            let thresh = new cv.Mat();
            let contours = new cv.MatVector();
            let hierarchy = new cv.Mat();
            
            // 3. PR√â-PROCESSAMENTO: Detec√ß√£o de Refer√™ncias (4 Quadrados Pretos)
            
            // 3.1. Thresholding para isolar as marcas pretas (escuras)
            cv.GaussianBlur(gray, blurred, new cv.Size(5, 5), 0);
            // Inverte o limiar: tudo que √© mais escuro que 50 vira branco (255), o resto vira preto (0)
            cv.threshold(blurred, thresh, 50, 255, cv.THRESH_BINARY_INV);
            
            // 3.2. Encontrar Contornos
            cv.findContours(thresh, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

            let biggestContours = [];
            let minAreaThreshold = 500; 
            
            // Filtra os 4 maiores contornos que s√£o suficientemente grandes (as marcas de refer√™ncia)
            for (let i = 0; i < contours.size(); ++i) {
                let contour = contours.get(i);
                let area = cv.contourArea(contour);
                if (area > minAreaThreshold) {
                    biggestContours.push({ area: area, contour: contour });
                }
            }
            
            // Ordenar por √°rea e pegar os 4 maiores (os 4 pontos de refer√™ncia)
            biggestContours.sort((a, b) => b.area - a.area);
            
            // Limpa contornos extras antes de prosseguir
            for(let i = 4; i < biggestContours.length; i++) {
                biggestContours[i].contour.delete();
            }

            if (biggestContours.length < 4) {
                 // Limpeza de mem√≥ria antes de lan√ßar o erro
                 src.delete(); gray.delete(); blurred.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
                 throw new Error(`N√£o foi poss√≠vel detectar as 4 marcas de refer√™ncia (apenas ${biggestContours.length} encontradas). Ajuste a ilumina√ß√£o, contraste ou tente tirar a foto mais de perto. **√Årea M√≠nima: ${minAreaThreshold}**`);
            }
            
            // 3.3. Obter os 4 pontos de refer√™ncia (os centroides dos 4 maiores contornos)
            const refPoints = [];
            for(let i = 0; i < 4; i++) {
                let M = cv.moments(biggestContours[i].contour);
                let cX = M.m10 / M.m00;
                let cY = M.m01 / M.m00;
                refPoints.push({ x: cX, y: cY });
                biggestContours[i].contour.delete(); // Limpa o contorno
            }
            
            // 3.4. Ordenar os pontos para garantir a ordem (Top-Left, Top-Right, Bottom-Right, Bottom-Left)
            refPoints.sort((a, b) => a.y - b.y); // Ordena de cima para baixo
            const topPoints = refPoints.slice(0, 2);
            const bottomPoints = refPoints.slice(2, 4);
            topPoints.sort((a, b) => a.x - b.x); // Ordena esquerda-direita
            bottomPoints.sort((a, b) => a.x - b.x); 
            
            const orderedPoints = [
                topPoints[0],      // Top-Left (TL)
                topPoints[1],      // Top-Right (TR)
                bottomPoints[1],   // Bottom-Right (BR)
                bottomPoints[0]    // Bottom-Left (BL)
            ];
            
            // 3.5. Corre√ß√£o de Perspectiva (Warpping)
            let dsize = new cv.Size(OUTPUT_WIDTH, OUTPUT_HEIGHT);
            let srcTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                orderedPoints[0].x, orderedPoints[0].y,
                orderedPoints[1].x, orderedPoints[1].y,
                orderedPoints[2].x, orderedPoints[2].y,
                orderedPoints[3].x, orderedPoints[3].y
            ]);
            
            let dstTri = cv.matFromArray(4, 1, cv.CV_32FC2, [
                0, 0, 
                OUTPUT_WIDTH, 0,
                OUTPUT_WIDTH, OUTPUT_HEIGHT, 
                0, OUTPUT_HEIGHT
            ]);
            
            let M = cv.getPerspectiveTransform(srcTri, dstTri);
            let warped = new cv.Mat();
            cv.warpPerspective(gray, warped, M, dsize, cv.INTER_LINEAR, cv.BORDER_CONSTANT, new cv.Scalar());
            
            // ***PASSO CRUCIAL PARA CALIBRA√á√ÉO: EXIBE A IMAGEM CORRIGIDA***
            cv.imshow('process-canvas', warped); 
            gabaritoPreview.src = processCanvas.toDataURL(); 
            gabaritoPreview.style.borderColor = '#28a745'; // Borda verde para sucesso na corre√ß√£o

            // 4. LEITURA DE MARCA√á√ïES (Detec√ß√£o de Bolhas)

            // 4.1. Configura√ß√µes de Leitura
            const respostas = {};
            const alternativas = ['A', 'B', 'C', 'D', 'E'].slice(0, NUM_ALTERNATIVAS);
            
            // Calibra√ß√£o dos Espa√ßos (Baseado no modelo de 2 colunas)
            const NUM_COLS = 2; // Duas colunas de quest√µes
            const QUESTOES_POR_COLUNA = NUM_QUESTOES / NUM_COLS; 
            
            // AJUSTE: Largura e Altura da √Årea Total de Respostas (em pixels)
            const TOTAL_RESPONSES_AREA_WIDTH = OUTPUT_WIDTH * 0.84; // 84% de 600
            const TOTAL_RESPONSES_AREA_HEIGHT = OUTPUT_HEIGHT * 0.75; // 75% de 850
            
            // AJUSTE: Offsets (em pixels)
            const X_OFFSET = OUTPUT_WIDTH * 0.08; // 8%
            const Y_OFFSET = OUTPUT_HEIGHT * 0.15; // 15%
            
            const COL_WIDTH = TOTAL_RESPONSES_AREA_WIDTH / NUM_COLS;
            const ROW_HEIGHT = TOTAL_RESPONSES_AREA_HEIGHT / QUESTOES_POR_COLUNA;
            
            // AJUSTE CR√çTICO: Limiar para considerar uma bolha preenchida (MAIS TOLERANTE POSS√çVEL)
            // Aumentado para 200: aceita marca√ß√µes muito mais claras.
            const THRESHOLD_FILL = 200; 

            // 4.2. Iterar sobre cada Quest√£o e Alternativa
            for (let q = 0; q < NUM_QUESTOES; q++) {
                
                const col = Math.floor(q / QUESTOES_POR_COLUNA);
                const row = q % QUESTOES_POR_COLUNA; 
                
                let respostaAluno = 'B'; 
                let marcacoesEncontradas = []; 
                
                // Coordenadas iniciais (superior esquerda) para a √°rea da QUEST√ÉO 'q'
                const x_q = X_OFFSET + (col * COL_WIDTH);
                const y_q = Y_OFFSET + (row * ROW_HEIGHT);
                
                const RESPONSE_AREA_WIDTH = COL_WIDTH * 0.6;
                const BOLHA_WIDTH = RESPONSE_AREA_WIDTH / NUM_ALTERNATIVAS; 
                
                // AJUSTE DO ROI: Centralizado e menor (16x16 pixels)
                const ROI_SIZE = 16; 
                const y_center = y_q + (ROW_HEIGHT / 2); // Centro vertical da linha da quest√£o

                for (let a = 0; a < NUM_ALTERNATIVAS; a++) {
                    
                    // Posi√ß√£o central X esperada da bolha 'a'
                    const x_center = x_q + (BOLHA_WIDTH * (a + 0.5));
                    
                    let bolhaRect = new cv.Rect(
                        x_center - (ROI_SIZE / 2),  // X inicial
                        y_center - (ROI_SIZE / 2), // Y inicial 
                        ROI_SIZE,             // Largura 
                        ROI_SIZE              // Altura 
                    );
                    
                    // Garante que o ROI n√£o saia dos limites
                    bolhaRect.x = Math.max(0, bolhaRect.x);
                    bolhaRect.y = Math.max(0, bolhaRect.y);
                    bolhaRect.width = Math.min(warped.cols - bolhaRect.x, bolhaRect.width);
                    bolhaRect.height = Math.min(warped.rows - bolhaRect.y, bolhaRect.height);

                    let bubbleROI = warped.roi(bolhaRect);
                    let mediaCor = cv.mean(bubbleROI)[0]; 
                    bubbleROI.delete();
                    
                    // Se estiver abaixo do limiar (mais escuro), √© uma marca√ß√£o
                    if (mediaCor < THRESHOLD_FILL) {
                        marcacoesEncontradas.push({
                            alt: alternativas[a],
                            escuridao: mediaCor
                        });
                    }
                }
                
                // 5. Regra de Decis√£o Final
                
                if (marcacoesEncontradas.length > 1) {
                    // M√∫ltipla marca√ß√£o
                    respostaAluno = 'X'; 
                } else if (marcacoesEncontradas.length === 1) {
                    // Marca√ß√£o √∫nica encontrada
                    respostaAluno = marcacoesEncontradas[0].alt;
                } else {
                    // Nenhuma marca√ß√£o encontrada
                    respostaAluno = 'B'; // Branco/N√£o marcado
                }

                // Armazenar a resposta (Q1, Q2, etc.)
                respostas[`Q${q + 1}`] = respostaAluno;
            }

            // 6. Cleanup
            src.delete(); gray.delete(); blurred.delete(); thresh.delete(); contours.delete(); hierarchy.delete();
            warped.delete(); M.delete(); srcTri.delete(); dstTri.delete();
            
            return respostas; 
        }

        // E. GERA√á√ÉO DE CSV E ENCERRAMENTO
        encerrarBtn.addEventListener('click', function() {
            if (dadosGabaritos.length === 0) {
                 resultadoDiv.textContent = "Nenhum gabarito processado para encerrar.";
                 return;
            }
            
            gerarDownloadCSV(); 
            
            // Resetar estado
            dadosGabaritos = [];
            gabaritoOficialRespostas = [];
            NUM_QUESTOES = 0;
            NUM_ALTERNATIVAS = 0;
            
            turmaInput.disabled = false;
            turmaInput.value = '';
            alunoInput.value = '';
            alunosCountSpan.textContent = '0';
            encerrarBtn.disabled = true;
            processarBtn.disabled = true;
            gabaritoRespostasArea.innerHTML = '';
            
            gabaritoOficialSection.style.display = 'none';
            inputSection.style.display = 'none';
            configSection.style.display = 'block';
            
            resultadoDiv.textContent = "üéâ CSV Gerado com sucesso! Aplica√ß√£o reiniciada para uma nova turma.";
            resultadoDiv.style.backgroundColor = '#fff3cd';
            resultadoDiv.style.borderColor = '#ffeeba';
            resultadoDiv.style.color = '#856404';
        });
        
        
        function gerarDownloadCSV() {
            const gabaritoOficialData = { "Aluno": "Gabarito Oficial" };
            for (let i = 1; i <= NUM_QUESTOES; i++) {
                gabaritoOficialData[`Q${i}`] = gabaritoOficialRespostas[i-1];
            }
            
            const dadosParaCSV = [gabaritoOficialData, ...dadosGabaritos];
            
            const separador = ';';
            const headers = Object.keys(dadosParaCSV[0]); 
            
            let csvString = headers.join(separador) + '\n';
            
            dadosParaCSV.forEach(row => {
                const values = headers.map(header => {
                    let value = row[header] !== undefined ? String(row[header]) : '';
                    return `"${value.replace(/"/g, '""')}"`;
                });
                csvString += values.join(separador) + '\n';
            });
            
            const turmaNome = turmaInput.value.trim().replace(/[^a-zA-Z0-9]/g, '_');
            const data = new Date().toISOString().slice(0, 10);
            const filename = `Gabaritos_${turmaNome}_${data}.csv`;

            const blob = new Blob([csvString], { type: 'text/csv;charset=utf-8;' });
            const link = document.createElement('a');
            
            if (link.download !== undefined) {
                const url = URL.createObjectURL(blob);
                link.setAttribute('href', url);
                link.setAttribute('download', filename);
                link.style.visibility = 'hidden';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
        }
    </script>
</body>
</html>
